# -*- coding: utf-8 -*-
"""CSCS 530 - Cellular Automata Examples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FRPoW3Xf7O1EMyMw_YWXcHKdlwJQOE_W
"""

# upgrade scipy
# !pip install scipy --upgrade
# nevermind, now Colab has this already now

''' if it's your first time running, click Runtime > Restart Runtime
    and rerun this cell '''

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
from numpy import linalg as la
import math
import scipy

print(scipy.__version__)
print(nx.__version__)

# Use the above to upgrade scipy etc


import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
from numpy import linalg as la
import math
import scipy
from matplotlib.colors import ListedColormap

print(scipy.__version__)
print(nx.__version__)

"""### Set up cellular automata rules

We'll set up a few different rules to choose from
"""

# Rule 50

'''
neighrule = {
        (0,0,0):0,
        (0,0,1):1,
        (0,1,0):0,
        (0,1,1):0,
        (1,0,0):1,
        (1,0,1):1,
        (1,1,0):0,
        (1,1,1):0
        }
'''

# Rule 13

neighrule = {
        (0,0,0):1,
        (0,0,1):0,
        (0,1,0):1,
        (0,1,1):1,
        (1,0,0):0,
        (1,0,1):0,
        (1,1,0):0,
        (1,1,1):0
        }


# Rule 30
'''
neighrule = {
        (0,0,0):0,
        (0,0,1):1,
        (0,1,0):1,
        (0,1,1):1,
        (1,0,0):1,
        (1,0,1):0,
        (1,1,0):0,
        (1,1,1):0
        }
'''

# Rule 110

'''
neighrule = {
        (0,0,0):0,
        (0,0,1):1,
        (0,1,0):1,
        (0,1,1):0,
        (1,0,0):1,
        (1,0,1):1,
        (1,1,0):1,
        (1,1,1):0
        }
'''

# Rule 184 (Majority rule not counting self, with ties awarded to 1)
'''
neighrule = {
        (0,0,0):0,
        (0,0,1):1,
        (0,1,0):0,
        (0,1,1):1,
        (1,0,0):1,
        (1,0,1):1,
        (1,1,0):1,
        (1,1,1):1
        }
'''

"""### Set up parameters to run the cellular automata"""

initialcond = [0,0,0,1,0,1,0,1,1,1] # for testing
L = 5 #9 #10 #14 #50  # Grid size (start with something small - eventually running something relatively "big" like size 14 on rule 110 and rule 30 is fun)

"""### Useful functions for running the model

We'll start with two functions to convert between decimal integers and binary model configurations
"""

# Takes a configuration and returns the corresponding integer
def config2int(config):
    return int(''.join(map(str, config)),2) # maps the config->strings, joins them, and then converts to int from binary

# Takes an integer and converts it to a configuration (list of cell states)
def int2config(x):
    return [1 if x & 2**i > 0 else 0 for i in range(L - 1, -1, -1)]

"""Next, a function to run the model--take the current configuration and map to next timestep"""

def update(config):
    nextconfig = [0]*L
    for x in range(L):
        nextconfig[x] = neighrule[(config[(x - 1) % L],config[x],config[(x + 1) % L])]
    return nextconfig

"""### Run the model

Run the model from our set initial conditions and plot the results
"""

# Run the model for a few steps and plot
steps = 50
output = np.zeros([steps,L])
output[0,:] = int2config(3)
for i in range(1,steps):
    output[i,:] = update(output[i-1,:])
plt.cla()
cmap = ListedColormap([(0,39/255,76/255), (241/255,196/255,0)]) # for fun use maize & blue colors
plt.imshow(output, cmap = cmap)

"""### Map out phase space!

We'll run the cellular automata model for every possible starting  configuration and add an edge linking each initial condition to where it goes next. Note there are $2^L$ total possible initial conditions.
"""

g = nx.DiGraph() # Make an empty graph that will be the phase space

for x in range(2**L):
    g.add_edge(x, config2int(update(int2config(x))))

print(g)

# Plot each connected component of the phase space
ccs = [cc for cc in nx.connected_components(g.to_undirected())]
n = len(ccs)
print(n)
w = math.ceil(math.sqrt(n))
h = math.ceil(n / w)

#plt.figure(1, figsize = (12,12))
plt.figure(1, figsize = (20,20))
for i in range(n):
    plt.subplot(h, w, i + 1)
    nx.draw_networkx(nx.subgraph(g, ccs[i]), with_labels = True)

plt.show()
# Suplots are sometimes too packed, so also useful to just draw a few individually
#nx.draw_networkx(nx.subgraph(g, ccs[1]), with_labels = True)

print("Undirected graph diameter: ", max([nx.diameter(nx.subgraph(g, ccs[j]).to_undirected()) for j in range(n)])   )

print("Largest directed shortest path:", max([max(j.values()) for (i,j) in nx.shortest_path_length(g)]) )

"""### Analyzing the phase space

##### Highlight an attracting sub-component

We can highlight those nodes that form an attracting subcomponent within the network (i.e. the set of nodes for which once we have entered that set we will not exit the set---potentially this is the whole subcomponent!).
"""

subg = nx.subgraph(g, ccs[1])
attr = set().union(*nx.attracting_components(subg))

'''
plt.figure(2, figsize=(10,7))
pos=nx.spring_layout(subg) # positions for all nodes
nx.draw_networkx_nodes(subg,pos, nodelist = (set(subg.nodes()) - attr), node_color='#00b4e9', node_size=200, alpha=0.8)
nx.draw_networkx_nodes(subg, pos, nodelist = attr, node_color='r', node_size=200, alpha=0.8)
nx.draw_networkx_edges(subg,pos,width=2.0, alpha = 0.8)
#nx.draw_networkx_labels(subg,pos)
plt.show()
'''
pos=nx.spring_layout(subg) # positions for all nodes
plt.figure(2, figsize=(20,20))
#pos=nx.spring_layout(subg) # positions for all nodes
nx.draw_networkx_nodes(subg,pos, nodelist = (set(subg.nodes()) - attr), node_color='#2F65A7', node_size=300, alpha=0.8)
nx.draw_networkx_nodes(subg, pos, nodelist = attr, node_color='#FFCB05', node_size=300, alpha=0.8)
nx.draw_networkx_edges(subg,pos,width=1.0, alpha = 0.8)
#nx.draw_networkx_labels(subg,pos)
plt.show()

"""##### Check whether there are any cycles (oscillations) in this component"""

# Check if cycles
list(nx.simple_cycles(nx.subgraph(g,ccs[1])))

"""##### Highlight network centrality

In this example, we've used degree centrality
"""

plt.figure(3, figsize = (10,7))
nx.draw_networkx_nodes(subg, pos, node_color=list(nx.degree_centrality(subg).values()), node_size=100, alpha=0.8)
nx.draw_networkx_edges(subg,pos,width=2.0)
#nx.draw_networkx_labels(subg,pos)
plt.show()

